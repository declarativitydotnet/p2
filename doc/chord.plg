/*
 * 1.0 Chord
 * ---------
 */

/* The base tuples */
materialise(node,2,infinity,1).
materialise(finger,5,infinity,16).
materialise(sucessor,4,infinity,16).
materialise(predecessor,3,infinity,1).


lookupResults(R,K,S,SI,E) :-
	node(NI,N),
	lookup(NI,K,R,E),
	bestSuccessor(NI,S,SI),
	gt(N,K), gte(K,S).

bestLookupDistance(NI,K,R,E,min<D>) :-
	lookup(NI,K,R,E),
	finger(NI,I,B,BI,ET),
	K>B,
	ET>f_currentTime(),
	D=f_dist(B,K).

lookup(BI,K,R,E) :-
	bestLookupDistance(NI,K,R,E,D),
	finger(NI,I,B,BI,ET),
	D=f_dist(B,K),
	K>B,
	ET>f_currentTime().

/* 1.2 Neighbor Selection Rules */

bestSuccessorID(NI,min<D>) :-
	node(NI,N),
	successor(NI,S,SI,ET),
	ET>f_currentTime(),
	D=f_dist(S,N).

bestSuccessor(NI,S,SI,ET) :-
	node(NI,N),
	bestSuccessorID(NI,D),
	successor(NI,S,SI,ET),
	D=f_dist(S,N),
	ET>f_currentTime().

// Successor replacement policy:

bestKSuccessorID(NI,min-k<D,successor.size>) :-
	node(NI,N),
	successor(NI,S,SI,ET),
	ET>f_currentTime(),
	D=f_dist(S,N).

successor(NI,S,SI,ET) :-
	node(NI,N),
	successor(NI,S,SI,ET),
	bestKSuccessorID(NI,S1),
	f_dist(S,N)>S1,
	ET = -1 .

// Fingers: 

finger(NI,K,B,BI,ET) :-
	fix_finger(NI,E),
	lookupResults(NI,K,B,BI,E),
	ET=(f_currentTime()+finger.TTL).

lookup(NI,K,NI,E) :-
	fix_finger(NI,E),
	fingerIndex(NI, I),
	K=[(NI+2I) mod 2^m] .

fingerIndex(NI, I) :-
	fix_finger(NI,E),
	fingerIndex(NI, I1),
	I=([I1+1] mod fingerIndex.size).

/* ?? F4: fingerIndex(NI,0)
F5: fix_finger(ni,e), period=finger.TTL*0.5

Periodically, add a fix_finger(ni,e) tuple to repair the ith finger
entry starting from 0. If finger entry non-existant, creates it.  To
build the finger table eagerly, we can call fix_finger for all finger
entries. The less the period beteween each call to fix fingers, the more
accurate the fingers will be. Set to half of finger TTL. 

*/

/* 1.3 Churn Handling */

lookup(NI,N,NI,E) :-
	node(NI,N),
	join(NI,N,E).


successor(NI,S,SI,ET) :-
	join(NI,N,E),
	lookupResults(NI,K,S,SI,E),
	ET=(f_currentTime() + successor.TTL) .

predecessor(NI,null,null).

/*
The tuple join(ni,n,e) is added as input for node ni to join n. A lookup
message with id q is generated by rule J1. Results is used to initialize
the successor in J2. If this is the first node, J2 will set successor to
itself. 

Stabilization:

Update successor:
S1: stabilizeRequest(SI, NI,E) :- stabilize(N1,E), bestSuccessor(N1,S,SI,ET)
S2: sendPredecessor(NI,P,PI,E) :- stabilizeRequest(NI,PI1,E),
predecessor(NI,P,PI), P != null 
S3: successor(NI,P,PI,ET) :- node(NI,N), sendPredecessor(NI,P,PI,E),
bestSuccessor(NI,S,SI,ET), N<P<S, ET=(f_currentTime()+successor.TTL) 

Get successor list:
S4: sendSuccessors(NI,S,SI) :- stabilize(NI,PI,E), successor(NI,S,SI)
S5: successor(NI,S,SI,ET) :- sendSuccessors(NI,S,SI),
ET=(f_currentTime()+successor.TTL) 

Update predecessor:
S6: notifyPredecessor(SI,N,NI,E) :- notify(NI,E), node(NI,N),
successor(NI,S,SI,ET) 
S7: predecessor(NI,P,PI) :- node(NI,N), notifyPredessor(NI,P,PI,E),
predecessor(NI,P1,PI1), (P1 == null || (P1<P<N)) 

Periodically, generate a stabilize(ni,e) and notify(ni,e) events. The
stablize event is used to improve upon the immediate successor (S1-S3),
and also for each node to get its successor lists from its successor
(S4-S5). Upon receiving successors, S5 may result in current successor
entries being evicted (based on the replacement policy). S6 and S7 are
used to notify a successor node about the current predecessor, and
update if necessary. If there is only a single successor, we do not need
S4 and S5. 

SendSucessors, stabilizeRequest, stabilize, notify, notifyPredecessor
are all event tuples with TTL=0. 


1.4 Failure Detection
---------------------

Periodically detect failures in predecessor and successors, and then
invalidate them by setting their expiration time. Failure detection is
based on pings in our example. The smaller the TTL, the more accurate
failures are detected. 

Set of pingNodes. Each have TTL and next scheduled ping. So periodically
scan the list for nodes to ping. The result of pings is in the
pingResult tuple, which has RTT set to -1 if timeout. 

P1: ping(X,Y) :- checkPing(X), pingNodes(X,Y), (lastPingTime(X,Y,T)
P2: ping(X,Y) :- checkPing(X), pingNodes(X,Y), lastPingTime(X,Y,T),
f_currentTime() > T + ping.TTL 
P3: lastPingTime(X,Y,T) :- ping(X,Y), T=f_currentTime()
P4: checkPing(X), period=ping_interval

Check Predecessor
CP1: pingNodes(NI,SI) :- predecessor(NI,S,SI)
CP2: predecesssor(NI,S,SI) :- pingResult(NI,SI,RTT),
predecessor(NI,S,SI), ET=(f_currentTime() + predecessor.TTL), RTT>=0 
CP3: predecessor(NI,null,null) :- pingResult(NI,SI,RTT),
predecessor(NI,S,SI), RTT<0 

PingNodes tuples will result in ping element performing periodic pings,
every TTL.. This ping element will do a ping, and then generate a
pingResult either after timeout or when the ping reply comes back. If
pingResult is successful, increase TTL, otherwise, set TTL to a negative
number to be purged by the vacumm cleaner. Ping and pingResult have TTLs
of 0. 

Check Successor
CP1: pingNodes(NI,SI) :- successor(NI,S,SI)

Repeat the same for sucessors. If not alive, set ET=-1 or field values
to null. For those already not alive, do not bother to probe. May check
only the closest successor (need to keep the first live successor), and
do the regular exchanges for the others. 

Check Fingers?
Called at higher frequency compared to fix fingers. If not alive, set ET=-1.

*/