/*
 * 1.1 Chord
 * ---------
 */

/* The base tuples */
materialise(node, 2, infinity, 1).
materialise(finger, 4, infinity, 16).
materialise(successor, 3, infinity, 16).
materialise(predecessor, 3, infinity, 1).
materialise(bestSuccessor, 3, infinity, 1).
materialize(nextFingerFix, 2, infinity, 1).
materialize(fingerLookup, 3, infinity, 16).
materialize(stabilize, 2, infinity, 1).
materialize(joinRecord, 2, infinity, 1).


/** Lookups */

rule L1 lookupResults@R(R,K,S,SI,E) :-
	node@NI(NI,N),
	lookup@NI(NI,K,R,E),
	bestSuccessor@NI(NI,S,SI),
	K in (N,S].

rule L2 bestLookupDistance@NI(NI,K,R,E,min<D>) :-
	lookup@NI(NI,K,R,E),
	finger@NI(NI,I,B,BI),
	node@NI(NI, N),
	B in (N,K),
	D=f_dist(B,K)-1.

rule L3 lookup@BI(min<BI>,K,R,E) :-
	bestLookupDistance@NI(NI,K,R,E,D),
	finger@NI(NI,I,B,BI),
	D=f_dist(B,K)-1,
	node@NI(NI, N),
	B in (N, K).



/* Neighbor Selection */

rule SU1 bestSuccessorDist@NI(NI,min<D>) :-
	node@NI(NI,N),
	successor@NI(NI,S,SI),
	D=f_dist(N,S)-1.

rule SU2 bestSuccessor@NI(NI,S,SI) :-
	node@NI(NI,N),
	bestSuccessorDist@NI(NI,D),
	successor@NI(NI,S,SI),
	D=f_dist(N,S)-1.

rule SR1 successorCount(NI,count<>) :-
	successor(NI,S,SI).

rule SR2 evictSuccessor@NI(NI) :-
	successorCount@NI(NI,C),
	C>successor.size.

rule SR3 maxSuccessorDist@NI(NI,max<D>) :-
	successor@NI(NI,S,SI),
	node@NI(NI,N),
	D = f_dist(N,S)-1,
	evictSuccessor@NI(NI).

rule SR4 delete@NI<successor(NI,S,SI)> :-
	successor@NI(NI,S,SI),
	maxSuccessorDist@NI(NI,D),
	D=f_dist(N,S)-1.

rule F1 fixFinger@NI(ni) :-
	periodic@NI(finger.TTL*0.5).

rule F2 nextFingerFix@NI(ni, 0).

rule F3 fingerLookup@NI(NI, E, I) :-
	fixFinger@NI(NI),
	E = random(),
	nextFingerFix@NI(NI, I).

rule F4 lookup@NI(NI, K, NI, E) :-
	fingerLookup@NI(NI, E, I),
	node(NI, N),
	K = N + 1 << I.

rule F5 finger@NI(NI, I, B, BI) :-
	fingerLookup@NI(NI, E, I),
	lookupResults@NI(NI, K, B, BI, E).

rule F6 nextFingerFix@NI(NI, I) :-
	fingerLookup@NI(NI, E, I1),
	lookupResults@NI(NI, K, B, BI, E),
	I = I1 + 1 mod finger.SIZE.



/* Churn Handling */

rule J1 join@NI(NI,E) :-
	joinEvent@NI(NI), E=f_rand().

rule J2 joinRecord@NI(NI,E) :-
	join@NI(NI,E).

rule J3 startJoin@LI(LI,N,NI,E) :-
	join@NI(NI,E),
	node@NI(NI,N),
	landmarkNode@NI(NI,LI),
	LI != "-".

rule J4 lookup@LI(LI,N,NI,E) :-
	startJoin@LI(LI,N,NI,E).

rule J5 successor@NI(NI,S,SI) :-
	joinRecord@NI(NI,E),
	lookupResults@NI(NI,K,S,SI,E).

rule J6 predecessor@NI(ni,null,"-").

rule J7 successor@NI(NI, N, NI) :-
	landmarkNode@NI(NI, LI),
	node@NI(NI, N),
	join@NI(NI, E),
	LI == "-".


/* Stabilization */

rule S0 stabilizeEvent@NI(ni) :-
	periodic@NI(TTL * 0.5).

rule S0a stabilize@NI(NI, E) :-
	stabilizeEvent@NI(NITTL * 0.5), E=f_rand(), NI=ni.

rule S0b stabilizeRecord@NI(NI, E) :-
	stabilize@NI(NI, E).

rule S1 stabilizeRequest@SI(SI,NI,E) :-
	stabilize@NI(NI,E),
	bestSuccessor@NI(NI,S,SI), 

rule S2 sendPredecessor@PI1(PI1,P,PI,E) :-
	stabilizeRequest@NI(NI,PI1,E),
	predecessor@NI(NI,P,PI),
	PI != "-".

rule S3 successor@NI(NI,P,PI) :-
	node(NI,N),
	sendPredecessor@NI(NI,P,PI,E),
	bestSuccessor@NI(NI,S,SI),
	P in (N,S),
	stabilizeRecord@NI(NI, E).

rule S4 sendSuccessors@SI(SI,NI,E) :-
	stabilizeRecord@NI(NI,E),
	successor@NI(NI,S,SI),
	f_coinFlip().

rule S5 returnSuccessor@PI(PI,S,SI,E) :-
	sendSuccessors@NI(NI,PI,E),
	successor@NI(NI,S,SI).

rule S5a successor@NI(NI, S, SI) :-
	returnSuccessor@NI(NI,S,SI,E),
	stabilizeRecord@NI(NI, E).

rule S6a notify@NI(NI) :-
	periodic@NI(TTL * 0.5), NI=ni.

rule S6 notifyPredecessor@SI(SI,N,NI) :-
	notify@NI(NI),
	node@NI(NI,N),
	successor@NI(NI,S,SI).

rule S7 predecessor@NI(NI,P,PI) :-
	node@NI(NI,N),
	notifyPredecessor@NI(NI,P,PI),
	predecessor@NI(NI,P1,PI1),
	((PI1 == "") || (P in (P1, N))).

/** 

1.4 Failure Detection
---------------------

Periodically detect failures in predecessor and successors, and then
invalidate them by setting their expiration time. Failure detection is
based on pings in our example. The smaller the TTL, the more accurate
failures are detected. 

Set of pingNodes. Each have TTL and next scheduled ping. So periodically
scan the list for nodes to ping. The result of pings is in the
pingResult tuple, which has RTT set to -1 if timeout. 

P1: ping(X,Y) :- checkPing(X), pingNodes(X,Y), (lastPingTime(X,Y,T)
P2: ping(X,Y) :- checkPing(X), pingNodes(X,Y), lastPingTime(X,Y,T),
f_currentTime() > T + ping.TTL 
P3: lastPingTime(X,Y,T) :- ping(X,Y), T=f_currentTime()
P4: checkPing(X), period=ping_interval

Check Predecessor
CP1: pingNodes(NI,SI) :- predecessor(NI,S,SI)
CP2: predecesssor(NI,S,SI) :- pingResult(NI,SI,RTT),
predecessor(NI,S,SI), ET=(f_currentTime() + predecessor.TTL), RTT>=0 
CP3: predecessor(NI,null,null) :- pingResult(NI,SI,RTT),
predecessor(NI,S,SI), RTT<0 

PingNodes tuples will result in ping element performing periodic pings,
every TTL.. This ping element will do a ping, and then generate a
pingResult either after timeout or when the ping reply comes back. If
pingResult is successful, increase TTL, otherwise, set TTL to a negative
number to be purged by the vacumm cleaner. Ping and pingResult have TTLs
of 0. 

Check Successor
CP1: pingNodes(NI,SI) :- successor(NI,S,SI)

Repeat the same for sucessors. If not alive, set ET=-1 or field values
to null. For those already not alive, do not bother to probe. May check
only the closest successor (need to keep the first live successor), and
do the regular exchanges for the others. 

Check Fingers?
Called at higher frequency compared to fix fingers. If not alive, set ET=-1.

*/
