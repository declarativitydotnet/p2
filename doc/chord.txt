1.0 Chord
---------

The base tuples:
node(currentNodeIP, currentNodeID), TTL=infinity, size=1
finger(currentNodeIP, targetID, bestID, bestIP), size=n,
where n=2^m
successor(currentNodeIP, successorID, successorID),
size=n, where n=2^m
predecessor(currentNodeIP,  predecessorID, predecessorIP), TTL=infinity, size=1

The derived/result tuples:
lookupResults(requestNodeIP, key, answerNodeID, answerIP, eventID), TTL=0
bestSuccessor(currentNodeIP, successorID, successorIP),
size=1, TTL=infinity 

The event tuples:
lookup(currentNodeIP, key, requestNodeIP, eventID) , TTL=0
join(currentNodeIP, bootstrapNodeID, eventID) , TTL=0
fix_finger(currentNodeIP, index, eventID) , TTL=0
stabilize(currentNodeIP, eventID) , TTL=0
checkPredecessor(currentNodeIP, eventID), TTL=0

Table metadata:
primary key(s)
size - the size of a table. If unspecified, tables can be arbitrary
large. Replacement policy can be expressed as rules.  If no rules,
FIFO. 
TTL - Default duration of a tuple within table. If TTL=0, messages flow
through the dataflow engine and are not materialized at any point.
Typically, event tuples have TTL of 0. If TTL=infinity, tuples never
expire. If TTL is above 0 but less than infinite, then each tuple needs
to have an implicit (hidden) expirationTime field. A vacuum cleaner periodically purges
tuples with the expiration time less than the current time.   Each tuple
also has an implicit active field, which is initialized to true, but set
to false when delete<tuple> is invoked.


1.1 Route Selection Rules
-------------------------  

L1: lookupResults@R(R,K,S,SI,E) :- node@NI(NI,N), lookup@NI(NI,K,R,E),
bestSuccessor@NI(NI,S,SI), K in (N,S]

L2: bestLookupDistance@NI(NI,K,R,E,min<D>) :- lookup@NI(NI,K,R,E),
finger@NI(NI,I,B,BI), B in (N,K), D=f_dist(B,K)

L3: lookup@BI(BI,K,R,E) :- bestLookupDistance@NI(NI,K,R,E,D),
finger@NI(NI,I,B,BI), D=f_dist(B,K), B in (N, K)

To perform a lookup on key k, node n generates an event tuple
lookup(n,k,n,e) where e is a globally unique eventID. This is a
continuous query, where there is one stream of lookup tuples that probe
the finger table. The result of the query is a lookupResults tuple
returned back to node n. L1 indicates the base case (success) is
reached. Otherwise, L2 will generate a new lookup tuple and recursively
forwards along the best finger that minimizes the f_dist distance
between the best finger ID and the required key K (where K does not
exceed that finger ID).  

Details: L2 generates bestFingerDistance every second, and aggregate
state for each lookup event can be purged periodically to save memory
(since lookup is a transcient tuple). The next lookup tuple is generated
whenever bestFingerDistance is generated. Random routing: setting f_dist
to return a random value will result in a random routing policy. 


1.2 Neighbor Selection Rules
----------------------------

Best Successor:
SU1: bestSuccessorDist@NI(NI,min<D>) :- node@NI(NI,N), successor@NI(NI,S,SI),
D=f_dist(N,S) 
SU2: bestSuccessor@NI(NI,S,SI) :- node@NI(NI,N), bestSuccessorDist@NI(NI,D),
successor@NI(NI,S,SI), D=f_dist(N,S)

Successor replacement policy:
SR1: successorCount(NI,count<>) :- successor(NI,S,SI)
SR2: evictSuccessor@NI(NI) :- successorCount@NI(NI,C), C>successor.size
SR3: maxSuccessorDist@NI(NI,max<D>) :- successor@NI(NI,S,SI),
node@NI(NI,N), D = f_dist(N,S), evictSuccessor@NI(NI)
SR4: delete@NI<successor(NI,S,SI)> :- successor@NI(NI,S,SI),
maxSuccessorDist@NI(NI,D), D=f_dist(N,S)

Fingers: 

F1: fixFinger@NI(ni), period=finger.TTL*0.5

F2: nextFingerFix@NI(ni, 0).

F3: fingerLookup@NI(NI, E, I) :- fixFinger@NI(NI), E = random(),
nextFingerFix@NI(NI, I)

F4: lookup@NI(NI, K, NI, E) :- fingerLookup@NI(NI, E, I), node(NI, N), K
= N + 1 << I

F5: finger@NI(NI, K, B, BI) :- fingerLookup@NI(NI, E, I),
lookupResults@NI(NI, K, B, BI, E)

F6: nextFingerFix@NI(NI, I) :- fingerLookup@NI(NI, E, I1),
lookupResults@NI(NI, K, B, BI, E), I = I1 + 1 mod finger.SIZE


Periodically, add a fix_finger(ni) tuple to repair the ith finger
entry starting from 0. If finger entry non-existant, creates it.  To
build the finger table eagerly, we can call fix_finger for all finger
entries. The less the period beteween each call to fix fingers, the more
accurate the fingers will be. Set to half of finger TTL. 


1.3 Churn Handling

Join:
J1: lookup@NI(NI,N,NI,E) :- node@NI(NI,N), join@NI(NI,N,E)
J2: successor@NI(NI,S,SI) :- join@NI(NI,N,E), lookupResults@NI(NI,K,S,SI,E)
J3: predecessor@NI(NI,null,null)

The tuple join(ni,n,e) is added as input for node ni to join n. A lookup
message with id q is generated by rule J1. Results is used to initialize
the successor in J2. If this is the first node, J2 will set successor to
itself. 

Stabilization:

Update successor:
S1: stabilizeRequest@SI(SI,NI,E) :- stabilize@N1(N1,E), bestSuccessor@N1(N1,S,SI)
S2: sendPredecessor@NI(NI,P,PI,E) :- stabilizeRequest@NI(NI,PI1,E),
predecessor@NI(NI,P,PI), P != null 
S3: successor@NI(NI,P,PI) :- node(NI,N), sendPredecessor@NI(NI,P,PI,E),
bestSuccessor@NI(NI,S,SI), P in (N,S)

Get successor list:
S4: sendSuccessors@NI(NI,S,SI) :- stabilize@NI(NI,PI,E),
successor@NI(NI,S,SI), f_coinFlip()
S5: successor@NI(NI,S,SI) :- sendSuccessors@NI(NI,S,SI)

Update predecessor:
S6: notifyPredecessor@SI(SI,N,NI,E) :- notify@NI(NI,E), node@NI(NI,N),
successor@NI(NI,S,SI) 
S7: predecessor@NI(NI,P,PI) :- node@NI(NI,N), notifyPredessor@NI(NI,P,PI,E),
predecessor@NI(NI,P1,PI1), (P1 == null || (P1<P<N)) 

Periodically, generate a stabilize(ni,e) and notify(ni,e) events. The
stablize event is used to improve upon the immediate successor (S1-S3),
and also for each node to get its successor lists from its successor
(S4-S5). Upon receiving successors, S5 may result in current successor
entries being evicted (based on the replacement policy). S6 and S7 are
used to notify a successor node about the current predecessor, and
update if necessary. If there is only a single successor, we do not need
S4 and S5. 

We can modify S4 and S5 to only exchange with random neighbors using the
f_coinFlip() above.

SendSucessors, stabilizeRequest, stabilize, notify, notifyPredecessor
are all event tuples with TTL=0. 


1.4 Failure Detection
---------------------

Periodically detect failures in predecessor and successors, and then
invalidate them. Failure detection is
based on pings in our example. The smaller the TTL, the more accurate
failures are detected. 

Set of pingNodes. Each have TTL and next scheduled ping. So periodically
scan the list for nodes to ping. The result of pings is in the
pingResult tuple, which has RTT set to -1 if timeout. 

P1: ping@X(X,Y) :- checkPing@X(X), pingNodes@X(X,Y), lastPingTime@X(X,Y,T),
f_currentTime() > T + ping.TTL 
P2: lastPingTime(X,Y,T) :- ping(X,Y), T=f_currentTime()
P3: checkPing(X), period=ping_interval

Check Predecessor
CP1: pingNodes@NI(NI,SI) :- predecessor@NI(NI,S,SI)
CP2: predecesssor@NI(NI,S,SI) :- pingResult@NI(NI,SI,RTT),
predecessor@NI(NI,S,SI), RTT>=0 
CP3: predecessor@NI(NI,null, null) :- pingResult@NI(NI,SI,RTT),
predecessor@NI(NI,S,SI), RTT<0 

PingNodes tuples will result in ping element performing periodic pings,
every TTL. We have a table which keeps the last ping time for each node
X to ensure we do not ping more than the ping interval. This ping element will do a ping, and then generate a
pingResult either after timeout or when the ping reply comes back. If
pingResult is successful, increase TTL, otherwise, either delete, or in
CP3, set fields to null for predecessor. Ping and pingResult have TTLs
of 0. 

Check Successor
CP1: pingNodes@NI(NI,SI) :- successor@NI(NI,S,SI)

Repeat the same for sucessors simply by running CP1 which adds to
pingNodes. If not alive, use the <delete> command.

Check Fingers?
Called at higher frequency compared to fix fingers. If not alive, delete.








