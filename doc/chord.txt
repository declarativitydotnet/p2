1.0 Chord

The base tuples:
node(currentNodeIP, currentNodeID), TTL=infinity, size=1
finger(currentNodeIP, targetID, bestID, bestIP, expirationTime), size=log(number of nodes)
successor(currentNodeIP, successorID, successorIP, expirationTime), size=log(number of nodes)
predecessor(currentNodeIP,  predecessorID, predecessorIP, expirationTime), size=1

The derived/result tuples:
lookupResults(requestNodeIP, answerNodeID, answerIP, eventID), TTL=0
bestSuccessor(currentNodeIP, successorID, successorIP, expirationTime), size=1, TTL=infinity

The event tuples:
lookup(currentNodeIP, key, requestNodeIP, eventID) , TTL=0
join(currentNodeIP, bootstrapNodeID, eventID) , TTL=0
fix_finger(currentNodeIP, index, eventID) , TTL=0
stabilize(currentNodeIP, eventID) , TTL=0
checkPredecessor(currentNodeIP, eventID)

Table metadata:
size - the size of a table. If unspecified, tables can be arbitrary large. Replacement policy can be expressed as rules.  If no rules, FIFO.
TTL - Default duration of a tuple within table. If TTL=0, messages flow through the dataflow engine and are not materialized at any point.  Typically, event tuples have TTL of 0. If TTL=infinity, tuples never expire. A vacuum cleaner periodically purges tuples with the expiration time less than the current time. If TTL is somewhere in between each tuple needs to have an expirationTime field.


1.1 Route Selection
L1: lookupResults(R,S,SI,E) :- node(NI,N), lookup(NI,K,R,E),  bestSuccessor(NI,S,SI), K (N,S]
L2: bestFingerDistance(NI,E, min<f_dist(B,K)>) :- lookup(NI,K,R,E), finger(NI,I,B,BI,ET), K>B, ET>f_currentTime()
L3: lookup(BI,K,R,E) :- bestFingerDistance(NI,E,D), finger(NI,I,B,BI,ET), lookup(NI,K,R,E) D=f_dist(B,K), K>B, ET>f_currentTime()

To perform a lookup on key k, node n generates an event tuple lookup(n,k,n,e) where e is a globally unique eventID. The result of the query is a lookupResults tuple returned back to node n. L1 indicates the base case (success) is reached. Otherwise, L2 will generate a new lookup tuple and recursively forwards along the best finger that minimizes the f_dist distance between the best finger ID and the required key K (where K does not exceed that finger ID). 

Random routing: setting f_dist to return a random value will result in a random routing policy.

1.2 Neighbor Selection
Pick finger entries and successors

Best Successor:
SU1: bestSuccessorID(NI,min<f_dist(S.N)>) :- node(NI,N), successor(NI,S,SI,ET),  ET>f_currentTime()
SU2: bestSuccessor(NI,S,SI,ET) :- node(NI,N), bestSuccessorID(NI,D), successor(NI,S,SI,ET), D=f_dist(S,N), ET>f_currentTime()

Successor replacement policy:
SR1: bestKSuccessorID(NI,min-k<f_dist(S.N)>) :- node(NI,N), successor(NI,S,SI, ET), ET>f_currentTime()
SR2: replaceSuccessor(NI,S,SI,ET) :- node(NI,N), successor(NI,S,SI,ET), bestKSuccessorID(NI,S1), f_dist(S,N)>S1

The current bestSuccessor is the successor with the lowest ID (SU1). SR1 and SR2 is used to decide if a successor is to be purged. Only the r closest successors are kept. If replaceSuccessor is true, it will be removed.

If there is only one successor, the rules SU1-2 and SR1-2 are not needed, and we just need a rule that sets the first finger entry to be the successor.

Fingers
F1: finger(NI,K,B,BI,ET) :- fix_finger(NI,I,E), lookupResults(NI,B,BI,E), K=[(NI+2I) mod 2m], ET=f_currentTime()+finger.TTL
F2: lookup(NI,K,NI,E) :- fix_finger(NI,I,E,ET), fingerIndex(NI, I) K=[(NI+2I) mod 2m]
F3: fingerIndex(NI, I) :- fingerIndex(NI, I1), I=[I+I1] mod fingerIndex.size
F4: fix_finger(ni,e), period=finger.TTL

Periodically, add a fix_finger(ni,e) tuple to repair the ith finger entry (loop from 0 to n-1), where n is the number of finger table entries). If finger entry non-existant, creates it.  To build the finger table eagerly, we can call fix_finger for all finger entries. The less the period beteween each call to fix fingers, the more accurate the fingers will be. fingerIndex has TTL of infinity.


1.3 Churn Handling
Join:
J1: lookup(NI,N,NI,E) :- node(NI, N), join(NI, N, E)
J2: successor(NI, S, SI,ET) :- join(NI,N,E), lookupResults(NI,S,SI,E), ET=f_currentTime() + successor.TTL

The tuple join(ni,n,e) is added as input for node ni to join n. A lookup message with id q is generated by rule J1. Results is used to initialize the successor in J2.

Stabilization:

Update successor:
S1: stabilizeRequest(SI, NI,E) :- stabilize(N1,E), bestSuccessor(N1,S,SI,ET)
S2: sendPredecessor(NI,P,PI,E) :- stabilizeRequest(NI,PI1,E), predecessor(NI,P,PI,ET), ET>f_currentTime()
S3: successor(NI,P,PI,ET) :- node(NI,N), sendPredecessor(NI,P,PI,E), bestSuccessor(NI,S,SI,ET), P (N,S), ET=f_currentTime()+successor.TTL

Get successor list:
S4: sendSuccessors(NI,S,SI) :- stabilize(NI,PI,E), successor(NI,S,SI)
S5: successor(NI,S,SI,ET) :- sendSuccessors(NI,S,SI), ET=f_currentTime()+successor.TTL

Update predecesssor:
S6: notifyPredecessor(SI,N,NI,E) :- notify(NI,E), node(NI,N), successor(NI,S,SI,ET)
S7: predecessor(NI,P,PI,ET) :- node(NI,N), notifyPredessor(NI,P,PI,E), predecessor(NI,P1,PI1,ET), (P1=nil or P  (P1,N)),  ET=f_currentTime()+successor.TTL

Periodically, generate a stabilize(ni,e) and notify(ni,e) events. The stablize event is used to improve upon the immediate successor (S1-S3), and also for each node to get its successor lists from its successor (S4-S5). S5 may result in current successor list entries from being evicted (based on the replacement policy). S6 and S7 are used to notify a successor node about the current predecessor. If there is only a single successor, we don't need S4 and S5.

SendSucessors, stabilizeRequest, stabilize, notify, notifyPredecessor are all event tuples with TTL=0.

1.4 Failure Detection
Periodically detect failures in predecessors and successors, and then invalidate them by setting their expiration time. Failure detection is based on pings in our example.

Check Predecessor
CP1: ping(NI,SI) :- checkPredecessor(NI,E), predecessor(NI,S,SI)
CP2: predecesssor(NI,S,SI,ET) :- pingReply(NI,SI,true), predecessor(NI,S,SI,ET1), ET=f_currentTime() + predecessor.TTL
CP2: predecessor(NI,S,SI,ET) :- pingReply(NI,SI,false), predecessor(NI,S,SI,ET1), ET=-1
CP4: checkPredecessor(ni, e), period=predecessor.TTL

Periodically, generate a checkPredecessor(ni,e) event tuple. Ping tuple will invoke a special ping element that will do a ping, and then generate a pingReply either after timeout or when the ping reply comes back. If pingReply is successful, increase TTL, otherwise, set TTL to a negative number to be purged by the vacumm cleaner. Ping and pingReply have TTLs of 0.

Check Successor
Repeat the same for sucessors 



Gossip Network




Multicast Overlay
Fill in.








