1.0 Chord
---------

The base tuples:
node(currentNodeIP, currentNodeID), TTL=infinity, size=1
finger(currentNodeIP, targetID, bestID, bestIP, expirationTime), size=n,
where n=2^m
successor(currentNodeIP, successorID, successorIP, expirationTime),
size=n, where n=2^m
predecessor(currentNodeIP,  predecessorID, predecessorIP), TTL=infinity, size=1

The derived/result tuples:
lookupResults(requestNodeIP, key, answerNodeID, answerIP, eventID), TTL=0
bestSuccessor(currentNodeIP, successorID, successorIP),
size=1, TTL=infinity 

The event tuples:
lookup(currentNodeIP, key, requestNodeIP, eventID) , TTL=0
join(currentNodeIP, bootstrapNodeID, eventID) , TTL=0
fix_finger(currentNodeIP, index, eventID) , TTL=0
stabilize(currentNodeIP, eventID) , TTL=0
checkPredecessor(currentNodeIP, eventID), TTL=0

Table metadata:
primary key(s)
size - the size of a table. If unspecified, tables can be arbitrary
large. Replacement policy can be expressed as rules.  If no rules,
FIFO. 
TTL - Default duration of a tuple within table. If TTL=0, messages flow
through the dataflow engine and are not materialized at any point.
Typically, event tuples have TTL of 0. If TTL=infinity, tuples never
expire. If TTL is above 0 but less than infinite, then each tuple needs
to have an expirationTime field. A vacuum cleaner periodically purges
tuples with the expiration time less than the current time.  


1.1 Route Selection Rules
-------------------------  

L1: lookupResults@R(R,K,S,SI,E) :- node@NI(NI,N), lookup@NI(NI,K,R,E),
bestSuccessor@NI(NI,S,SI), K in (N,S]

L2: bestLookupDistance@NI(NI,K,R,E,min<D>) :- lookup@NI(NI,K,R,E),
finger@NI(NI,I,B,BI,ET), B in (N,K), D=f_dist(B,K)

L3: lookup@BI(BI,K,R,E) :- bestLookupDistance@NI(NI,K,R,E,D),
finger@NI(NI,I,B,BI), D=f_dist(B,K), B in (N, K)

To perform a lookup on key k, node n generates an event tuple
lookup(n,k,n,e) where e is a globally unique eventID. This is a
continuous query, where there is one stream of lookup tuples that probe
the finger table. The result of the query is a lookupResults tuple
returned back to node n. L1 indicates the base case (success) is
reached. Otherwise, L2 will generate a new lookup tuple and recursively
forwards along the best finger that minimizes the f_dist distance
between the best finger ID and the required key K (where K does not
exceed that finger ID).  

Details: L2 generates bestFingerDistance every second, and aggregate
state for each lookup event can be purged periodically to save memory
(since lookup is a transcient tuple). The next lookup tuple is generated
whenever bestFingerDistance is generated. Random routing: setting f_dist
to return a random value will result in a random routing policy. 


1.2 Neighbor Selection Rules
----------------------------

Best Successor:
SU1: bestSuccessorID@NI(NI,min<D>) :- node@NI(NI,N), successor@NI(NI,S,SI),
D=f_dist(S,N) 
SU2: bestSuccessor@NI(NI,S,SI,ET) :- node@NI(NI,N), bestSuccessorID@NI(NI,D),
successor@NI(NI,S,SI,ET), D=f_dist(S,N), ET>f_currentTime() 

Successor replacement policy:
SR1: bestKSuccessorID@NI(NI,min-k<D,successor.size>) :- node@NI(NI,N),
successor@NI(NI,S,SI,ET), ET>f_currentTime(), D=f_dist(S,N)
SR2: successor@NI(NI,S,SI,ET) :- node@NI(NI,N), successor@NI(NI,S,SI,ET),
bestKSuccessorID@NI(NI,S1), f_dist(S,N)>S1, ET = -1 

The current bestSuccessor is the successor with the lowest ID (SU1). SR1
and SR2 is used to decide if a successor is to be purged (by setting ET
to -1 or having an 'active' flag as one of the fields). Only the r
closest successors are kept. SU1-2 and SR1-2 are invoked whenever a new
successor is added or updated. It is best if we can do the replacements
at the tables level.  
 
If there is only one successor, the rules SU1-2 and SR1-2 are not
needed, and we just need a rule that sets the first finger entry to be
the successor. 

Fingers: 
F1: finger@NI(NI,K,B,BI,ET) :- fix_finger@NI(NI,E),
lookupResults@NI(NI,K,B,BI,E), ET=(f_currentTime()+finger.TTL) 
F2: lookup@NI(NI,K,NI,E) :- fix_finger@NI(NI,E), fingerIndex@NI(NI, I),
K=[(NI+2I) mod 2^m] 
F3: fingerIndex@NI(NI, I) :- fix_finger@NI(NI,E), fingerIndex@NI(NI, I1),
I=([I1+1] mod fingerIndex.size) 
F4: fingerIndex@NI(NI,0)
F5: fix_finger@NI(ni,e), period=finger.TTL*0.5

Periodically, add a fix_finger(ni,e) tuple to repair the ith finger
entry starting from 0. If finger entry non-existant, creates it.  To
build the finger table eagerly, we can call fix_finger for all finger
entries. The less the period beteween each call to fix fingers, the more
accurate the fingers will be. Set to half of finger TTL. 


1.3 Churn Handling

Join:
J1: lookup@NI(NI,N,NI,E) :- node@NI(NI,N), join@NI(NI,N,E)
J2: successor@NI(NI,S,SI,ET) :- join@NI(NI,N,E), lookupResults@NI(NI,K,S,SI,E),
ET=(f_currentTime() + successor.TTL) 
J3: predecessor@NI(NI,null,null)

The tuple join(ni,n,e) is added as input for node ni to join n. A lookup
message with id q is generated by rule J1. Results is used to initialize
the successor in J2. If this is the first node, J2 will set successor to
itself. 

Stabilization:

Update successor:
S1: stabilizeRequest@SI(SI,NI,E) :- stabilize@N1(N1,E), bestSuccessor@N1(N1,S,SI,ET)
S2: sendPredecessor@NI(NI,P,PI,E) :- stabilizeRequest@NI(NI,PI1,E),
predecessor@NI(NI,P,PI), P != null 
S3: successor@NI(NI,P,PI,ET) :- node(NI,N), sendPredecessor@NI(NI,P,PI,E),
bestSuccessor@NI(NI,S,SI,ET), P in (N,S), ET=(f_currentTime()+successor.TTL) 

Get successor list:
S4: sendSuccessors@NI(NI,S,SI) :- stabilize@NI(NI,PI,E), successor@NI(NI,S,SI)
S5: successor@NI(NI,S,SI,ET) :- sendSuccessors@NI(NI,S,SI),
ET=(f_currentTime()+successor.TTL) 

Update predecessor:
S6: notifyPredecessor@SI(SI,N,NI,E) :- notify@NI(NI,E), node@NI(NI,N),
successor@NI(NI,S,SI,ET) 
S7: predecessor@NI(NI,P,PI) :- node@NI(NI,N), notifyPredessor@NI(NI,P,PI,E),
predecessor@NI(NI,P1,PI1), (P1 == null || (P1<P<N)) 

Periodically, generate a stabilize(ni,e) and notify(ni,e) events. The
stablize event is used to improve upon the immediate successor (S1-S3),
and also for each node to get its successor lists from its successor
(S4-S5). Upon receiving successors, S5 may result in current successor
entries being evicted (based on the replacement policy). S6 and S7 are
used to notify a successor node about the current predecessor, and
update if necessary. If there is only a single successor, we do not need
S4 and S5. 

We can modify S4 and S5 to only exchange with random neighbors.

SendSucessors, stabilizeRequest, stabilize, notify, notifyPredecessor
are all event tuples with TTL=0. 


1.4 Failure Detection
---------------------

Periodically detect failures in predecessor and successors, and then
invalidate them by setting their expiration time. Failure detection is
based on pings in our example. The smaller the TTL, the more accurate
failures are detected. 

Set of pingNodes. Each have TTL and next scheduled ping. So periodically
scan the list for nodes to ping. The result of pings is in the
pingResult tuple, which has RTT set to -1 if timeout. 

P1: ping@X(X,Y) :- checkPing@X(X), pingNodes@X(X,Y), lastPingTime(X,Y,T),
f_currentTime() > T + ping.TTL 
P2: lastPingTime(X,Y,T) :- ping(X,Y), T=f_currentTime()
P3: checkPing(X), period=ping_interval

Check Predecessor
CP1: pingNodes@NI(NI,SI) :- predecessor@NI(NI,S,SI)
CP2: predecesssor@NI(NI,S,SI) :- pingResult@NI(NI,SI,RTT),
predecessor@NI(NI,S,SI), ET=(f_currentTime() + predecessor.TTL), RTT>=0 
CP3: predecessor@NI(NI,null,null) :- pingResult@NI(NI,SI,RTT),
predecessor@NI(NI,S,SI), RTT<0 

PingNodes tuples will result in ping element performing periodic pings,
every TTL.. This ping element will do a ping, and then generate a
pingResult either after timeout or when the ping reply comes back. If
pingResult is successful, increase TTL, otherwise, set TTL to a negative
number to be purged by the vacumm cleaner. Ping and pingResult have TTLs
of 0. 

Check Successor
CP1: pingNodes@NI(NI,SI) :- successor@NI(NI,S,SI)

Repeat the same for sucessors. If not alive, set ET=-1 or field values
to null. For those already not alive, do not bother to probe. May check
only the closest successor (need to keep the first live successor), and
do the regular exchanges for the others. 

Check Fingers?
Called at higher frequency compared to fix fingers. If not alive, set ET=-1.









